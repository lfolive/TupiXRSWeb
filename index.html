<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title>Simulador Tupi</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
      <link rel="stylesheet" href="css/my_styles.css">

      <script type="text/javascript"
              src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
      <script type="text/javascript" src="lib/jquery.js"></script>
      <!--<script type="text/javascript" src="lib/jquery_plantuml.js"></script>-->
      <script type="text/javascript" src="lib/jquery_plantuml.js"></script>
      <!-- rawdeflate.js is implicity used by jquery_plantuml.js -->

      <script>
         MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
                     svg: { fontCache: 'global' } };
      </script>
      <script type="text/javascript" id="MathJax-script" async
              src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
      </script>

      <script>
         function showVerticalNav() {
           var x = document.getElementById("demo");
           if (x.className.indexOf("w3-show") == -1) {
             x.className += " w3-show";
           } else { 
             x.className = x.className.replace(" w3-show", "");
           }
         }
      </script>

   </head>

   <body>
      <!--menu-->
      <header class="w3-content">
         <div class="w3-cell-row">
            <div class="w3-cell w3-cell-middle" style="width:100px">

               <img src="images/logo_uerj_cor.jpg" 
                    style="padding-top:18px;padding-bottom:18px;width:90%;" 
                    class="w3-rounded" alt="Logo UERJ">

            </div>
            <div class="w3-cell w3-cell-middle">

               <!--menu horizontal-->
               <div class="w3-bar w3-white w3-topbar w3-bottombar borda-ocre">

                  <a id="1" href="index.html" 
                     class="w3-bar-item w3-button texto-ocre
                            w3-hover-none 
                            texto-ocre-hover" style="padding-top:18px;padding-bottom:21px;">
                     Início
                  </a>
                  <a id="2" href="processo_modelagem.html"
                     class="w3-bar-item w3-button
                            w3-hover-none
                            texto-ocre-hover
                            w3-hide-small">
                     Metodologia<br>de Modelagem
                  </a>
                  <a id="3" href="mod_material.html"
                     class="w3-bar-item w3-button
                            w3-hover-none 
                            texto-ocre-hover
                            w3-hide-small">
                     Modelagem dos<br>Meios Materiais
                  </a>
                  <a id="4" href="#3"
                     class="w3-bar-item w3-button
                            w3-hover-none 
                            texto-ocre-hover
                            w3-hide-small">
                     Link 3
                  </a>
                  <a class="w3-bar-item w3-button w3-right
                            w3-hide-large w3-hide-medium"
                     onclick="showVerticalNav()" style="padding-top:18px;">
                     &#9776;
                  </a>

               </div>

            </div>
         </div>

         <!--menu vertical-->
         <div id="demo"
              class="w3-bar-block w3-white w3-hide
                     w3-hide-large w3-hide-medium">

            <a id="2" href="processo_modelagem.html"
               class="w3-bar-item w3-button
                      w3-hover-none
                      texto-ocre-hover">
               Metodologia de Modelagem
            </a>
            <a id="3" href="mod_material.html"
               class="w3-bar-item w3-button
                      w3-hover-none
                      texto-ocre-hover">
               Modelagem dos Meios Materiais
            </a>
            <a id="4" href="#3"
               class="w3-bar-item w3-button
                      w3-hover-none
                      texto-ocre-hover">
               Link 3
            </a>

         </div>
      </header>

      <!--banner-->
      <header class="w3-center fundo-azul w3-text-white">
         <!--tirar as margens-->
         <div class="w3-content w3-padding-16 secao">
            Tupi: Simulador Monte Carlo em Charm++
         </div>
      </header>

<!--conteúdo-->
<div class="w3-content w3-container">

<div class="subsecao">
Introdução
</div>

<div class="w3-panel w3-leftbar borda-azul">
A técnica de Monte Carlo é amplamente utilizada nas implementações computacionais que simulam processos estocásticos. Exemplos na Física não faltam. Simuladores computacionais para aplicações em física das radiações utilizam a técnica de Monte Carlo com muita frequência.
</div>

<div class="w3-panel w3-leftbar borda-azul">
Estes simuladores utilizam, em sua maioria, processos como "histórias" de eventos, isto é, simulam a criação de eventos com características controladas por distribuições de probabilidade e acompanham a evolução deste evento. A evolução em si também é função de distribuições de probabilidade. O final de cada história depende de condições tais como absorsão, detecção ou perda para o meio e, ao encerrar uma história, dá-se início a um novo evento (nova história).
</div>

<div class="w3-panel w3-leftbar borda-azul">
Como os simuladores são geralmente utilizados, entre outros objetivos, como fonte de dados para planejamento e avaliação de cenários de resultados experimentais, o parâmetro <b>estatística de contagem</b> é sempre um elemento de grande peso, ou seja, o número de eventos (histórias) deve ser suficientemente grande para garantir que os resultados obtidos pela simulação possam ser considerados estatisticamente representativos. Como consequência, o tempo de processamento, o tempo de simulação, normalmente é elevado.
</div>

<div class="w3-panel w3-leftbar borda-azul">
Para se reduzir este tempo de simulação, mantendo-se a estatística de contagem, pode-se adotar diferentes estratégias. Neste projeto, o foco está no uso de processamento paralelo e distribuído pela implementação de um simulador desenvolvido em linguagem de programação paralela/distribuída: <b>Charm++</b> (KALE; ZHENG, 2013). 
</div>

<div class="w3-panel w3-leftbar borda-azul">
Na física do raio x, como as histórias dos fótons (os eventos) não se interferem, ou seja, são processos independentes, e os estados intermediários das histórias não dependem dos estados anteriores, isto é, são processos markovianos, uma abordagem possível para redução do tempo de simulação é a paralelização/distribuição das histórias dos fótons.
</div>

<div class="w3-panel w3-leftbar borda-azul">
Em um ambiente de computação com $n$ processadores disponíveis, pode-se executar $n$ histórias simultaneamente. Logo, o tempo de processamento paralelizado tende a $T(n)=T(1)/n$, onde $T(1)$ é o tempo de execução com 1 processador. A otimização é medida como <b>speedup</b> $s$ que é a taxa de "aceleração" do processamento: $s=T(1)/T(n)$. No caso ideal, isto é, com processos trivialmente paralelizáveis (sem execuções seriais), o speedup será $s=n$.
</div>

<div class="w3-panel w3-leftbar borda-azul">
No dia a dia, o tempo de processamento é a soma dos tempos de processamento serial $T_s$ mais os de processamento paralelizável $T_p$ mais os de troca de mensagens $T_m$:
<br><br>
$T(1)=T_s+T_p+T_m$. 
<br><br>
Normalizando a expressão: 
<br><br>
$1=\dfrac{T_s+T_m}{T(1)}+\dfrac{T_p}{T(1)}=$ $NP + P$, 
<br><br>
onde $NP$ e $P$ são os percentuais de processamento não paralelizável e paralelizável respectivamente. Por uma questão de simplicificação, expressa-se o percentual não paralelizável como $NP=1-P$.
<br><br>
Assim, pode-se expressar o tempo $T(1)$ como:
<br><br>
$T(1) = T(1)[(1-P)+P]$
<br><br>
e o tempo $T(n)$ como:
<br><br>
$T(n) = T(1)\left[(1-P)+\dfrac{P}{n}\right]$.
<br><br>
O speedup $s$ passa a ser expresso como: 
<br><br>
$s = \dfrac{T(1)[(1-P)+P]}{T(1)\left[(1-P)+\dfrac{P}{n}\right]}=$ $\dfrac{1}{(1-P)+\dfrac{P}{n}}=$ $\dfrac{n}{n-(n-1)P}$.
<br><br>
Esta análise é conhecida como <b>argumento de Amdahl</b> ou <b>lei de Amdahl</b>.
</div>

<div class="w3-panel w3-leftbar borda-azul">
Para uma execução completamente serial ($P=0$), o speedup é 1 e para uma execução completamente paralelizável ($P=1$), o speedup é igual ao número de processos paralelos ($n$). A figura 1 a seguir exemplifica este comportamento para o caso hipotético de $n=10$. Na figura 2, observa-se, para diferentes taxas de paralelismo, o comportamento do speedup em função do número de processos paralelos.
</div>

<div class="w3-row-padding">
   <div class="w3-col m6 w3-card w3-margin w3-center" style="width:45%">
      <img src="images/speedup.png" style="width:100%">
      <div class="w3-container">
         <p>Figura 1. </p>
      </div>
   </div>
   <div class="w3-col m6 w3-card w3-margin w3-center" style="width:45%">
      <img src="images/speedup2.png" style="width:100%">
      <div class="w3-container">
         <p>Figura 2. </p>
      </div>
   </div>
</div>

<div class="w3-panel w3-leftbar borda-azul">
Se $n$ processos paralelos trocam mensagens entre si, tem-se que cada processador consome $(n-1)T_m$ para encaminhar suas mensagens. Por simplicidade, assume-se que o tempo é da ordem de $nT_m$. Assim, a expressão do speedup será:
<br><br>
$s=\dfrac{T(1)}{T(n)} = \dfrac{S+M+P}{S+nM+\dfrac{P}{n}}$,
<br><br>
onde $S=T_s/T(1)$ é a fração serial, $M=T_m/T(1)$ é a fração na comunicação de uma mensagem e $P=T_p/T(1)$ é a fração paralelizável.
</div>

<div class="w3-panel w3-leftbar borda-azul">
É perceptível que, com o aumento do número de processos paralelos, o tempo para as trocas de mensagens aumenta proporcionalmente. Para uma arquitetura de comunicação de baixa performance, o tempo consumido na comunicação pode tornar-se proibitivo e comprometer o ganho de processamento com o aumento de processos paralelos, ou seja, a performance deterioriza-se.
</div>

<div class="subsecao">Referências</div>
   <div class="w3-panel w3-leftbar borda-azul">
      <p>
        Kale, L. V.; Zheng, G. 
        <i>The Charm++ Programming Model</i>.
        In: Parallel Science and Engineering Applications: The Charm++ Approach,
        Kale, Laxmikant V. and Bhatele, Abhinav (Org.), 
        ch. 1, 
        p. 1-16. 
        Boca Raton, FL, USA: CRC Press, Inc., 2013. 
        <a href="https://charm.cs.illinois.edu/newPapers/13-46/paper.pdf">https://charm.cs.illinois.edu/newPapers/13-46/paper.pdf</a>
      </p>
   </div>
</div>

<div class="w3-panel"><br></div>

</div>

      <!--rodapé-->
      <footer class="w3-bottom fundo-azul w3-text-white">
         <!--tirar as margens-->
         <div class="w3-content w3-padding-16">
            rodapé
         </div>
      </footer>
   </body>
</html>
